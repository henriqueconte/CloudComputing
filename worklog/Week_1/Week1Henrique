### Setup

First, I had to install the software and make it run. Since I'm using a Macbook, the suggested step-by-step didn't work as expected.  

To install QEMU, I used Homebrew and that worked perfectly. However, to install ARM, I first downloaded the .pkg from the official website, and this created a folder in my Applications folder. I tried to run the Makefile then, but it couldn't find the arm files. 

Even though I changed the path to allow it to find the arm files, it still wouldn't work. Therefore, what worked for me was a solution hidden in Stack Overflow that showed a package we could install with Homebrew that worked. 


### Week 1, step 1

The VAB (Versatile Application Board) has a arm926 CPU, and 1MB of memory. In the other hand, the VPB (Versatile Platform Board) 
has a Cortex-a8 CPU and 32MB of memory.

I was able to compile the VPB board, but the VAP didn't work for me initially. To make it work, I had to ... 

A linker script is used to set up a memory map for the application, allocating RAM, disk space for I/O and registers. Then, the linker script sets up a memory map of this allocation that manages the chip. 

The bss section, also called as Block Starting Symbol, is contains static variables that haven't an assigned value yet. Since the variables don't have an initial value, the object file size is smaller. Besides, since there is no data in the bss section, the compiler puts variables in the segment because they should be zero-initialized.

In embedded systems, the bss section is mapped into memory, which is set to zero by the C run-time system before the main method begins to run. In C, static objects are initialized to zero or to null pointers. 

Therefore, when the OS loads the executable, it gets the bss section size, allocates the necessary memory for it and initialize it with zeros.

###########################################

Alignment refers to a piece of data's address location in memory. By having a 16-byte boundary, we are saying that the data memory address needs to divisible by 16. For example, 0x00010 would be 16-byte alligned, while 0x00011 wouldn't. The bss section is aligned on a 16-byte boundary because we zero 16-bytes at a time, as we can see in the ".clear" part from the reset.s file.

By running the command info mtree with the VPB board, I got the following result:

address-space: lsi-pci-io
  0000000043000000-0000000142ffffff (prio 0, i/o): pci_io

address-space: versatile_pci_host
  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container

address-space: cpu-memory-0
address-space: memory
address-space: pl080-downstream
  0000000000000000-ffffffffffffffff (prio 0, i/o): system
    0000000000000000-0000000001ffffff (prio 0, ram): versatile.ram
    0000000010000000-0000000010000fff (prio 0, i/o): arm-sysctl
    0000000010001000-0000000010001fff (prio 0, i/o): pci-vpb-regs
    0000000010002000-0000000010002fff (prio 0, i/o): arm_sbcon_i2c
    0000000010003000-0000000010003fff (prio 0, i/o): vpb-sic
    0000000010004000-0000000010004fff (prio 0, i/o): pl041
    0000000010005000-0000000010005fff (prio 0, i/o): pl181
    0000000010006000-0000000010006fff (prio 0, i/o): pl050
    0000000010007000-0000000010007fff (prio 0, i/o): pl050
    0000000010009000-0000000010009fff (prio 0, i/o): pl011
    000000001000b000-000000001000bfff (prio 0, i/o): pl181
    0000000010010000-000000001001000f (prio 0, i/o): smc91c111-mmio
    0000000010120000-0000000010120fff (prio 0, i/o): pl110
    0000000010130000-0000000010130fff (prio 0, i/o): pl080
    0000000010140000-0000000010140fff (prio 0, i/o): pl190
    00000000101e2000-00000000101e2fff (prio 0, i/o): sp804
    00000000101e3000-00000000101e3fff (prio 0, i/o): sp804
    00000000101e4000-00000000101e4fff (prio 0, i/o): pl061
    00000000101e5000-00000000101e5fff (prio 0, i/o): pl061
    00000000101e6000-00000000101e6fff (prio 0, i/o): pl061
    00000000101e7000-00000000101e7fff (prio 0, i/o): pl061
    00000000101e8000-00000000101e8fff (prio 0, i/o): pl031
    00000000101f1000-00000000101f1fff (prio 0, i/o): pl011
    00000000101f2000-00000000101f2fff (prio 0, i/o): pl011
    00000000101f3000-00000000101f3fff (prio 0, i/o): pl011
    0000000034000000-0000000037ffffff (prio 0, romd): versatile.flash
    0000000041000000-0000000041ffffff (prio 0, i/o): pci-vpb-selfconfig
    0000000042000000-0000000042ffffff (prio 0, i/o): pci-vpb-config
    0000000043000000-0000000142ffffff (prio 0, i/o): pci_io
    0000000044000000-000000004fffffff (prio 0, i/o): alias pci-vbp-window @pci_mem 0000000000000000-000000000bffffff
    0000000050000000-000000005fffffff (prio 0, i/o): alias pci-vbp-window @pci_mem 0000000000000000-000000000fffffff
    0000000060000000-000000006fffffff (prio 0, i/o): alias pci-vbp-window @pci_mem 0000000000000000-000000000fffffff

address-space: lsi53c895a
  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container

address-space: I/O
  0000000000000000-000000000000ffff (prio 0, i/o): io

memory-region: system
  0000000000000000-ffffffffffffffff (prio 0, i/o): system
    0000000000000000-0000000001ffffff (prio 0, ram): versatile.ram
    0000000010000000-0000000010000fff (prio 0, i/o): arm-sysctl
    0000000010001000-0000000010001fff (prio 0, i/o): pci-vpb-regs
    0000000010002000-0000000010002fff (prio 0, i/o): arm_sbcon_i2c
    0000000010003000-0000000010003fff (prio 0, i/o): vpb-sic
    0000000010004000-0000000010004fff (prio 0, i/o): pl041
    0000000010005000-0000000010005fff (prio 0, i/o): pl181
    0000000010006000-0000000010006fff (prio 0, i/o): pl050
    0000000010007000-0000000010007fff (prio 0, i/o): pl050
    0000000010009000-0000000010009fff (prio 0, i/o): pl011
    000000001000b000-000000001000bfff (prio 0, i/o): pl181
    0000000010010000-000000001001000f (prio 0, i/o): smc91c111-mmio
    0000000010120000-0000000010120fff (prio 0, i/o): pl110
    0000000010130000-0000000010130fff (prio 0, i/o): pl080
    0000000010140000-0000000010140fff (prio 0, i/o): pl190
    00000000101e2000-00000000101e2fff (prio 0, i/o): sp804
    00000000101e3000-00000000101e3fff (prio 0, i/o): sp804
    00000000101e4000-00000000101e4fff (prio 0, i/o): pl061
    00000000101e5000-00000000101e5fff (prio 0, i/o): pl061
    00000000101e6000-00000000101e6fff (prio 0, i/o): pl061
    00000000101e7000-00000000101e7fff (prio 0, i/o): pl061
    00000000101e8000-00000000101e8fff (prio 0, i/o): pl031
    00000000101f1000-00000000101f1fff (prio 0, i/o): pl011
    00000000101f2000-00000000101f2fff (prio 0, i/o): pl011
    00000000101f3000-00000000101f3fff (prio 0, i/o): pl011
    0000000034000000-0000000037ffffff (prio 0, romd): versatile.flash
    0000000041000000-0000000041ffffff (prio 0, i/o): pci-vpb-selfconfig
    0000000042000000-0000000042ffffff (prio 0, i/o): pci-vpb-config
    0000000043000000-0000000142ffffff (prio 0, i/o): pci_io
    0000000044000000-000000004fffffff (prio 0, i/o): alias pci-vbp-window @pci_mem 0000000000000000-000000000bffffff
    0000000050000000-000000005fffffff (prio 0, i/o): alias pci-vbp-window @pci_mem 0000000000000000-000000000fffffff
    0000000060000000-000000006fffffff (prio 0, i/o): alias pci-vbp-window @pci_mem 0000000000000000-000000000fffffff

memory-region: pci_mem
  0000000000000000-00000000ffffffff (prio 0, i/o): pci_mem

This command shows a mapping of the system memory to different devices. 


###### Week 1, step 2

To debug with GDB, I spent almost three hours trying to understand how remote debugging works. The step-by-step that finally worked for me was:

1. Open two terminal tabs
2. In the first one, run "make debug"
3. In the second one, run "sudo arm-none-eabi-gdb kernel.elf"
4. In the second one, run "break _reset"
5. In the second one, run "target remote:1234"
6. In the second one, run "run"

Then, in the second terminal, we can see that the execution will stop on the line 11 from the "reset" file. This line belongs to the "clear" section, which means we will first clean the memory, assign 0 to the memory addresses and then load the "main" file.

If we remove the periodic "Zzzz" output, we won't know the program is still running. The output was there to show that the program is being executed, and it is printed everytime the variable "count" reaches 10000000. This gives us the impression that the program is sleeping for a second and then printing, but the program is actually continously running and adding 1 to the count value, and then printing "Zzzz" when count reaches 10000000.

The symbol _stack_top is used to reference the top element of the stack. In our case, we are reserving memory for our C stack and then loading the C file (main) entry point. The stack growns downward, which means the top of the stack is at the end of the reserved memory region.

We can verify in C that the stack is working properly by being able to execute the program without running out of memory. The "Zzzzz" print is useful for that, because if we are printing "Zzzzz" that means that everything is good with the stack. 

However, if we call too many functions in C, we won't have enough memory in the stack region to run everything. This also happens if we declare way too big variables, like an array with 1 million of integers, we won't have memory in the data region.

Regarding the safety of C programs, it is important to mention that C is an unsafe programming language. If we execute an incorrect operation, the whole program becomes meaningless, having a undefined behavior. Since the compiler doesn't provide diagnostic for undefined behavior, we are susceptible to security vulnerabilities. 

We can verify the program C executes safely by using multiple validation approaches. First, the simplest and most obvious approach is to run the program multiple times with different inputs, trying to cover basic to edge cases. This may detect the presence of errors, but it can't prove its absence.

Another approach is to have code reviews whenever new code is written. This means that another person will review and run the proposed code, increasing the chances of finding wrong behaviors and bad written code. This also allows us to enforce the usage of good programming practies, that strongly reduce the existence of unsafe code.

Besides, another approach is to use static code analysis tools. Those tools can, for example, detect unitialized variables that may result in a bad execution afterwards. 

Last, it is also possible to provide a formal verification that the C program executes safely. In some companies, they use functional safety standards such as ISO 26262-6. However, the approach depends on the company needs, so there is not a unique way of ensuring safety. 


The method kprintf is the same as a "printf" but on a kernel version. Since we don't have libC on bare-metal environment, we can't simply use "printf", thus kprintf was implemented. 



############ Week 1 Step 3

UART, that stands for Universal Asynchronous Receiver-Transmitter, is a protocol allowing to send or receive bytes in an asynchronous serial communication. In that type of communication, data is transferred bit by bit with one line.

UART is widely used for embedded systems and microcontrollers, and it uses two wires to send and receive. The two signals are called Transmitter and Receiver. A transmitter receives data from a controlling data bus in parallel form, and sends to another UART in serial form. Then, the second UART sends the data to another data bus in parallel form. 

The information is transmitted in packets that contain a start bit (1 bit), a data frame (5 to 9 bits), parity bits (0 to 1 bits) and stop bits (1 to 2 bits). The start bit decides when the UART should start reading the data frame bits. The data frame contains the information from the package. The parity bits is used to identify if any data was modified during transmission, happening in case of electromagnetic interefence. The stop bits indicate the end of the package. 

In addition, UARTs have registers used to configure communication parameters, like the communication speed and parity check. In that aspect, 8 bytes are used to access a UART's registers. The offsets are used to access the right register, because we always need a base address plus an offset. 

Bit fields in C are variables with predefined width, and the easiest way to understand bit fields is with an example. Let's say we have the following structure:

struct {
    unsigned int age : 3;
} Age; 

Note the " : 3". Normally, the program would allocate 4 bytes for the variable "age", since it's a unsigned int. However, if we don't want to allocate that much memory for a variable, we can use bit fields to define the amount of bits we want to allocate to that variable. In that case, we use " : 3" to say that we want to allocate 3 bits for the variable age. That means we could only have ages from 0 to 7 - which is quite low -, but it's enough to understand the concept of bit fields.




It has bit fields to...
 


References: 
https://users.informatik.haw-hamburg.de/~krabat/FH-Labor/gnupro/7_GNUPro_Embedded_Development/embThe_linker_script.html
https://en.wikipedia.org/wiki/.bss
http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch19lev1sec3.html
https://www.geeksforgeeks.org/stack-top-c-stl/
https://blog.regehr.org/archives/213
https://www.mathworks.com/content/dam/mathworks/conference-or-academic-paper/how-to-prove-your-c-plus-plus-code-safe-secure.pdf
https://www.analog.com/en/analog-dialogue/articles/uart-a-hardware-communication-protocol.html
https://www.lammertbies.nl/comm/info/serial-uart
https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm





